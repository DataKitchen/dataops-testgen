test_types:
  id: '1500'
  test_type: Aggregate_Balance
  test_name_short: Aggregate Balance
  test_name_long: Aggregate values per group match reference
  test_description: |-
    Tests for exact match in aggregate values for each set of column values vs. reference dataset
  except_message: |-
    Aggregate measure per set of column values does not exactly match reference dataset.
  measure_uom: Mismatched measures
  measure_uom_description: null
  selection_criteria: null
  generation_template: null
  dq_score_prevalence_formula: |-
    1
  dq_score_risk_factor: '1.0'
  column_name_prompt: |-
    Aggregate Expression
  column_name_help: |-
    Specify an aggregate column expression: one of `SUM([column_name])` or `COUNT([column_name])`
  default_parm_columns: subset_condition,groupby_names,having_condition,match_schema_name,match_table_name,match_column_names,match_subset_condition,match_groupby_names,match_having_condition
  default_parm_values: null
  default_parm_prompts: |-
    Record Subset Condition,Grouping Columns,Group Subset Condition,Matching Schema Name,Matching Table Name,Matching Aggregate Expression,Matching Record Subset Condition,Matching Grouping Columns,Matching Group Subset Condition
  default_parm_help: |-
    Condition defining a subset of records in main table, written like a condition within a SQL WHERE clause - OPTIONAL|Category columns in main table separated by commas (e.g. GROUP BY columns)|Condition defining a subset of aggregate records in main table (e.g. HAVING clause) - OPTIONAL|Schema location of matching table|Matching table name|Agregate column expression in matching table: one of `SUM([column_name])` or `COUNT([column_name])`|Condition defining a subset of records in matching table, written like a condition within a SQL WHERE clause - OPTIONAL|Category columns in matching table separated by commas (e.g. GROUP BY columns)|Condition defining a subset of aggregate records in matching table (e.g. HAVING clause) - OPTIONAL
  default_severity: Fail
  run_type: QUERY
  test_scope: referential
  dq_dimension: Consistency
  health_dimension: Data Drift
  threshold_description: |-
    Expected count of group totals not matching aggregate value
  result_visualization: line_chart
  result_visualization_params: null
  usage_notes: |-
    This test compares sums or counts of a column rolled up to one or more category combinations across two different tables. Both tables must be accessible at the same time. It's ideal for confirming that two datasets exactly match -- that the sum of a measure or count of a value hasn't changed or shifted between categories. Use this test to compare a raw and processed version of the same dataset, or to confirm that an aggregated table exactly matches the detail table that it's built from. An error here means that one or more value combinations fail to match. New categories or combinations will cause failure.
  active: Y
  cat_test_conditions: []
  target_data_lookups:
  - id: '1400'
    test_id: '1500'
    test_type: Aggregate_Balance
    sql_flavor: bigquery
    lookup_type: null
    lookup_query: |-
      SELECT *
      FROM (
        SELECT {GROUPBY_NAMES}, SUM(TOTAL) AS total, SUM(MATCH_TOTAL) AS MATCH_TOTAL
        FROM (
          SELECT {GROUPBY_NAMES}, {COLUMN_NAME_NO_QUOTES} AS total, NULL AS match_total
          FROM `{TARGET_SCHEMA}`.`{TABLE_NAME}`
          WHERE {SUBSET_CONDITION}
          GROUP BY {GROUPBY_NAMES}
          {HAVING_CONDITION}
          UNION ALL
          SELECT {MATCH_GROUPBY_NAMES}, NULL AS total, {MATCH_COLUMN_NAMES} AS match_total
          FROM {MATCH_SCHEMA_NAME}.{MATCH_TABLE_NAME}
          WHERE {MATCH_SUBSET_CONDITION}
          GROUP BY {MATCH_GROUPBY_NAMES}
          {MATCH_HAVING_CONDITION}
        ) a
        GROUP BY {GROUPBY_NAMES}
      ) s
      WHERE total <> match_total OR (total IS NOT NULL AND match_total IS NULL) OR (total IS NULL AND match_total IS NOT NULL)
      ORDER BY {GROUPBY_NAMES}
      LIMIT {LIMIT};
    error_type: Test Results
  - id: '1333'
    test_id: '1500'
    test_type: Aggregate_Balance
    sql_flavor: databricks
    lookup_type: null
    lookup_query: |-
      SELECT *
        FROM ( SELECT {GROUPBY_NAMES}, SUM(TOTAL) AS total, SUM(MATCH_TOTAL) AS MATCH_TOTAL
                 FROM
                     ( SELECT {GROUPBY_NAMES}, {COLUMN_NAME_NO_QUOTES} AS total, NULL AS match_total
                         FROM `{TARGET_SCHEMA}`.`{TABLE_NAME}`
                        WHERE {SUBSET_CONDITION}
                       GROUP BY {GROUPBY_NAMES}
                       {HAVING_CONDITION}
                         UNION ALL
                       SELECT {MATCH_GROUPBY_NAMES}, NULL AS total, {MATCH_COLUMN_NAMES} AS match_total
                         FROM {MATCH_SCHEMA_NAME}.{MATCH_TABLE_NAME}
                        WHERE {MATCH_SUBSET_CONDITION}
                       GROUP BY {MATCH_GROUPBY_NAMES}
                       {MATCH_HAVING_CONDITION} ) a
              GROUP BY {GROUPBY_NAMES} ) s
       WHERE total <> match_total OR (total IS NOT NULL AND match_total IS NULL) OR (total IS NULL AND match_total IS NOT NULL)
      ORDER BY {GROUPBY_NAMES}
      LIMIT {LIMIT};
    error_type: Test Results
  - id: '1247'
    test_id: '1500'
    test_type: Aggregate_Balance
    sql_flavor: mssql
    lookup_type: null
    lookup_query: |-
      SELECT TOP {LIMIT} *
        FROM ( SELECT {GROUPBY_NAMES}, SUM(TOTAL) AS total, SUM(MATCH_TOTAL) AS MATCH_TOTAL
                 FROM
                     ( SELECT {GROUPBY_NAMES}, {COLUMN_NAME_NO_QUOTES} AS total, NULL AS match_total
                         FROM "{TARGET_SCHEMA}"."{TABLE_NAME}"
                        WHERE {SUBSET_CONDITION}
                       GROUP BY {GROUPBY_NAMES}
                       {HAVING_CONDITION}
                         UNION ALL
                       SELECT {MATCH_GROUPBY_NAMES}, NULL AS total, {MATCH_COLUMN_NAMES} AS match_total
                         FROM {MATCH_SCHEMA_NAME}.{MATCH_TABLE_NAME}
                        WHERE {MATCH_SUBSET_CONDITION}
                       GROUP BY {MATCH_GROUPBY_NAMES}
                       {MATCH_HAVING_CONDITION} ) a
              GROUP BY {GROUPBY_NAMES} ) s
       WHERE total <> match_total OR (total IS NOT NULL AND match_total IS NULL) OR (total IS NULL AND match_total IS NOT NULL)
      ORDER BY {GROUPBY_NAMES};
    error_type: Test Results
  - id: '1248'
    test_id: '1500'
    test_type: Aggregate_Balance
    sql_flavor: postgresql
    lookup_type: null
    lookup_query: |-
      SELECT *
        FROM ( SELECT {GROUPBY_NAMES}, SUM(TOTAL) AS total, SUM(MATCH_TOTAL) AS MATCH_TOTAL
                 FROM
                     ( SELECT {GROUPBY_NAMES}, {COLUMN_NAME_NO_QUOTES} AS total, NULL AS match_total
                         FROM "{TARGET_SCHEMA}"."{TABLE_NAME}"
                        WHERE {SUBSET_CONDITION}
                       GROUP BY {GROUPBY_NAMES}
                       {HAVING_CONDITION}
                         UNION ALL
                       SELECT {MATCH_GROUPBY_NAMES}, NULL AS total, {MATCH_COLUMN_NAMES} AS match_total
                         FROM {MATCH_SCHEMA_NAME}.{MATCH_TABLE_NAME}
                        WHERE {MATCH_SUBSET_CONDITION}
                       GROUP BY {MATCH_GROUPBY_NAMES}
                       {MATCH_HAVING_CONDITION} ) a
              GROUP BY {GROUPBY_NAMES} ) s
       WHERE total <> match_total OR (total IS NOT NULL AND match_total IS NULL) OR (total IS NULL AND match_total IS NOT NULL)
      ORDER BY {GROUPBY_NAMES}
      LIMIT {LIMIT};
    error_type: Test Results
  - id: '1245'
    test_id: '1500'
    test_type: Aggregate_Balance
    sql_flavor: redshift
    lookup_type: null
    lookup_query: |-
      SELECT *
        FROM ( SELECT {GROUPBY_NAMES}, SUM(TOTAL) AS total, SUM(MATCH_TOTAL) AS MATCH_TOTAL
                 FROM
                     ( SELECT {GROUPBY_NAMES}, {COLUMN_NAME_NO_QUOTES} AS total, NULL AS match_total
                         FROM "{TARGET_SCHEMA}"."{TABLE_NAME}"
                        WHERE {SUBSET_CONDITION}
                       GROUP BY {GROUPBY_NAMES}
                       {HAVING_CONDITION}
                         UNION ALL
                       SELECT {MATCH_GROUPBY_NAMES}, NULL AS total, {MATCH_COLUMN_NAMES} AS match_total
                         FROM {MATCH_SCHEMA_NAME}.{MATCH_TABLE_NAME}
                        WHERE {MATCH_SUBSET_CONDITION}
                       GROUP BY {MATCH_GROUPBY_NAMES}
                       {MATCH_HAVING_CONDITION} ) a
              GROUP BY {GROUPBY_NAMES} ) s
       WHERE total <> match_total OR (total IS NOT NULL AND match_total IS NULL) OR (total IS NULL AND match_total IS NOT NULL)
      ORDER BY {GROUPBY_NAMES}
      LIMIT {LIMIT};
    error_type: Test Results
  - id: '1462'
    test_id: '1500'
    test_type: Aggregate_Balance
    sql_flavor: redshift_spectrum
    lookup_type: null
    lookup_query: |-
      SELECT *
        FROM ( SELECT {GROUPBY_NAMES}, SUM(TOTAL) AS total, SUM(MATCH_TOTAL) AS MATCH_TOTAL
                 FROM
                     ( SELECT {GROUPBY_NAMES}, {COLUMN_NAME_NO_QUOTES} AS total, NULL AS match_total
                         FROM "{TARGET_SCHEMA}"."{TABLE_NAME}"
                        WHERE {SUBSET_CONDITION}
                       GROUP BY {GROUPBY_NAMES}
                       {HAVING_CONDITION}
                         UNION ALL
                       SELECT {MATCH_GROUPBY_NAMES}, NULL AS total, {MATCH_COLUMN_NAMES} AS match_total
                         FROM {MATCH_SCHEMA_NAME}.{MATCH_TABLE_NAME}
                        WHERE {MATCH_SUBSET_CONDITION}
                       GROUP BY {MATCH_GROUPBY_NAMES}
                       {MATCH_HAVING_CONDITION} ) a
              GROUP BY {GROUPBY_NAMES} ) s
       WHERE total <> match_total OR (total IS NOT NULL AND match_total IS NULL) OR (total IS NULL AND match_total IS NOT NULL)
      ORDER BY {GROUPBY_NAMES}
      LIMIT {LIMIT};
    error_type: Test Results
  - id: '1246'
    test_id: '1500'
    test_type: Aggregate_Balance
    sql_flavor: snowflake
    lookup_type: null
    lookup_query: |-
      SELECT *
        FROM ( SELECT {GROUPBY_NAMES}, SUM(TOTAL) AS total, SUM(MATCH_TOTAL) AS MATCH_TOTAL
                 FROM
                     ( SELECT {GROUPBY_NAMES}, {COLUMN_NAME_NO_QUOTES} AS total, NULL AS match_total
                         FROM "{TARGET_SCHEMA}"."{TABLE_NAME}"
                        WHERE {SUBSET_CONDITION}
                       GROUP BY {GROUPBY_NAMES}
                       {HAVING_CONDITION}
                         UNION ALL
                       SELECT {MATCH_GROUPBY_NAMES}, NULL AS total, {MATCH_COLUMN_NAMES} AS match_total
                         FROM {MATCH_SCHEMA_NAME}.{MATCH_TABLE_NAME}
                        WHERE {MATCH_SUBSET_CONDITION}
                       GROUP BY {MATCH_GROUPBY_NAMES}
                       {MATCH_HAVING_CONDITION} ) a
              GROUP BY {GROUPBY_NAMES} ) s
       WHERE total <> match_total OR (total IS NOT NULL AND match_total IS NULL) OR (total IS NULL AND match_total IS NOT NULL)
      ORDER BY {GROUPBY_NAMES}
      LIMIT {LIMIT};
    error_type: Test Results
  test_templates:
  - id: '2506'
    test_type: Aggregate_Balance
    sql_flavor: bigquery
    template: |-
      SELECT '{TEST_TYPE}'   as test_type,
             '{TEST_DEFINITION_ID}' as test_definition_id,
             '{TEST_SUITE_ID}' as test_suite_id,
             '{TEST_RUN_ID}' as test_run_id,
             '{RUN_DATE}'    as test_time,
             '{SCHEMA_NAME}' as schema_name,
             '{TABLE_NAME}'  as table_name,
             '{COLUMN_NAME_NO_QUOTES}' as column_names,
             '{SKIP_ERRORS}' as threshold_value,
             {SKIP_ERRORS} as skip_errors,
             '{INPUT_PARAMETERS}' as input_parameters,
             NULL as result_signal,
             CASE WHEN COUNT (*) > {SKIP_ERRORS} THEN 0 ELSE 1 END as result_code,
             CASE
              WHEN COUNT(*) > 0 THEN
                     CONCAT(
                            CONCAT( CAST(COUNT(*) AS {VARCHAR_TYPE}), ' error(s) identified, ' ),
                            CONCAT(
                                   CASE
                                     WHEN COUNT(*) > {SKIP_ERRORS} THEN 'exceeding limit of '
                                                                              ELSE 'within limit of '
                                   END,
                                   '{SKIP_ERRORS}.'
                                   )
                            )
              ELSE 'No errors found.'
             END AS result_message,
             COUNT(*) as result_measure
      FROM ( SELECT {GROUPBY_NAMES}, SUM(TOTAL) as total, SUM(MATCH_TOTAL) as MATCH_TOTAL
               FROM
                    ( SELECT {GROUPBY_NAMES}, {COLUMN_NAME_NO_QUOTES} as total, NULL as match_total
             FROM {QUOTE}{SCHEMA_NAME}{QUOTE}.{QUOTE}{TABLE_NAME}{QUOTE}
             WHERE {SUBSET_CONDITION}
             GROUP BY {GROUPBY_NAMES}
             {HAVING_CONDITION}
                    UNION ALL
                      SELECT {MATCH_GROUPBY_NAMES}, NULL as total, {MATCH_COLUMN_NAMES} as match_total
             FROM {QUOTE}{MATCH_SCHEMA_NAME}{QUOTE}.{QUOTE}{MATCH_TABLE_NAME}{QUOTE}
             WHERE {MATCH_SUBSET_CONDITION}
             GROUP BY {MATCH_GROUPBY_NAMES}
             {MATCH_HAVING_CONDITION} ) a
               GROUP BY {GROUPBY_NAMES} ) s
               WHERE total <> match_total
                   OR (total IS NOT NULL AND match_total IS NULL)
                   OR (total IS NULL AND match_total IS NOT NULL);
  - id: '2406'
    test_type: Aggregate_Balance
    sql_flavor: databricks
    template: |-
      SELECT '{TEST_TYPE}'   as test_type,
             '{TEST_DEFINITION_ID}' as test_definition_id,
             '{TEST_SUITE_ID}' as test_suite_id,
             '{TEST_RUN_ID}' as test_run_id,
             '{RUN_DATE}'    as test_time,
             '{SCHEMA_NAME}' as schema_name,
             '{TABLE_NAME}'  as table_name,
             '{COLUMN_NAME_NO_QUOTES}' as column_names,
             '{SKIP_ERRORS}' as threshold_value,
             {SKIP_ERRORS} as skip_errors,
             '{INPUT_PARAMETERS}' as input_parameters,
             NULL as result_signal,
             CASE WHEN COUNT (*) > {SKIP_ERRORS} THEN 0 ELSE 1 END as result_code,
             CASE
              WHEN COUNT(*) > 0 THEN
                     CONCAT(
                            CONCAT( CAST(COUNT(*) AS {VARCHAR_TYPE}), ' error(s) identified, ' ),
                            CONCAT(
                                   CASE
                                     WHEN COUNT(*) > {SKIP_ERRORS} THEN 'exceeding limit of '
                                                                              ELSE 'within limit of '
                                   END,
                                   '{SKIP_ERRORS}.'
                                   )
                            )
              ELSE 'No errors found.'
             END AS result_message,
             COUNT(*) as result_measure
      FROM ( SELECT {GROUPBY_NAMES}, SUM(TOTAL) as total, SUM(MATCH_TOTAL) as MATCH_TOTAL
               FROM
                    ( SELECT {GROUPBY_NAMES}, {COLUMN_NAME_NO_QUOTES} as total, NULL as match_total
             FROM {QUOTE}{SCHEMA_NAME}{QUOTE}.{QUOTE}{TABLE_NAME}{QUOTE}
             WHERE {SUBSET_CONDITION}
             GROUP BY {GROUPBY_NAMES}
             {HAVING_CONDITION}
                    UNION ALL
                      SELECT {MATCH_GROUPBY_NAMES}, NULL as total, {MATCH_COLUMN_NAMES} as match_total
             FROM {QUOTE}{MATCH_SCHEMA_NAME}{QUOTE}.{QUOTE}{MATCH_TABLE_NAME}{QUOTE}
             WHERE {MATCH_SUBSET_CONDITION}
             GROUP BY {MATCH_GROUPBY_NAMES}
             {MATCH_HAVING_CONDITION} ) a
               GROUP BY {GROUPBY_NAMES} ) s
               WHERE total <> match_total
                   OR (total IS NOT NULL AND match_total IS NULL)
                   OR (total IS NULL AND match_total IS NOT NULL);
  - id: '2206'
    test_type: Aggregate_Balance
    sql_flavor: mssql
    template: |-
      SELECT '{TEST_TYPE}'   as test_type,
             '{TEST_DEFINITION_ID}' as test_definition_id,
             '{TEST_SUITE_ID}' as test_suite_id,
             '{TEST_RUN_ID}' as test_run_id,
             '{RUN_DATE}'    as test_time,
             '{SCHEMA_NAME}' as schema_name,
             '{TABLE_NAME}'  as table_name,
             '{COLUMN_NAME_NO_QUOTES}' as column_names,
             '{SKIP_ERRORS}' as threshold_value,
             {SKIP_ERRORS} as skip_errors,
             '{INPUT_PARAMETERS}' as input_parameters,
             NULL as result_signal,
             CASE WHEN COUNT (*) > {SKIP_ERRORS} THEN 0 ELSE 1 END as result_code,
             CASE
              WHEN COUNT(*) > 0 THEN
                     CONCAT(
                            CONCAT( CAST(COUNT(*) AS {VARCHAR_TYPE}), ' error(s) identified, ' ),
                            CONCAT(
                                   CASE
                                     WHEN COUNT(*) > {SKIP_ERRORS} THEN 'exceeding limit of '
                                                                              ELSE 'within limit of '
                                   END,
                                   '{SKIP_ERRORS}.'
                                   )
                            )
              ELSE 'No errors found.'
             END AS result_message,
             COUNT(*) as result_measure
      FROM ( SELECT {GROUPBY_NAMES}, SUM(TOTAL) as total, SUM(MATCH_TOTAL) as MATCH_TOTAL
               FROM
                    ( SELECT {GROUPBY_NAMES}, {COLUMN_NAME_NO_QUOTES} as total, NULL as match_total
             FROM {QUOTE}{SCHEMA_NAME}{QUOTE}.{QUOTE}{TABLE_NAME}{QUOTE}
             WHERE {SUBSET_CONDITION}
             GROUP BY {GROUPBY_NAMES}
             {HAVING_CONDITION}
                    UNION ALL
                      SELECT {MATCH_GROUPBY_NAMES}, NULL as total, {MATCH_COLUMN_NAMES} as match_total
             FROM {QUOTE}{MATCH_SCHEMA_NAME}{QUOTE}.{QUOTE}{MATCH_TABLE_NAME}{QUOTE}
             WHERE {MATCH_SUBSET_CONDITION}
             GROUP BY {MATCH_GROUPBY_NAMES}
             {MATCH_HAVING_CONDITION} ) a
               GROUP BY {GROUPBY_NAMES} ) s
               WHERE total <> match_total
                   OR (total IS NOT NULL AND match_total IS NULL)
                   OR (total IS NULL AND match_total IS NOT NULL);
  - id: '2306'
    test_type: Aggregate_Balance
    sql_flavor: postgresql
    template: |-
      SELECT '{TEST_TYPE}'   as test_type,
             '{TEST_DEFINITION_ID}' as test_definition_id,
             '{TEST_SUITE_ID}' as test_suite_id,
             '{TEST_RUN_ID}' as test_run_id,
             '{RUN_DATE}'    as test_time,
             '{SCHEMA_NAME}' as schema_name,
             '{TABLE_NAME}'  as table_name,
             '{COLUMN_NAME_NO_QUOTES}' as column_names,
             '{SKIP_ERRORS}' as threshold_value,
             {SKIP_ERRORS} as skip_errors,
             '{INPUT_PARAMETERS}' as input_parameters,
             NULL as result_signal,
             CASE WHEN COUNT (*) > {SKIP_ERRORS} THEN 0 ELSE 1 END as result_code,
             CASE
              WHEN COUNT(*) > 0 THEN
                     CONCAT(
                            CONCAT( CAST(COUNT(*) AS {VARCHAR_TYPE}), ' error(s) identified, ' ),
                            CONCAT(
                                   CASE
                                     WHEN COUNT(*) > {SKIP_ERRORS} THEN 'exceeding limit of '
                                                                              ELSE 'within limit of '
                                   END,
                                   '{SKIP_ERRORS}.'
                                   )
                            )
              ELSE 'No errors found.'
             END AS result_message,
             COUNT(*) as result_measure
      FROM ( SELECT {GROUPBY_NAMES}, SUM(TOTAL) as total, SUM(MATCH_TOTAL) as MATCH_TOTAL
               FROM
                    ( SELECT {GROUPBY_NAMES}, {COLUMN_NAME_NO_QUOTES} as total, NULL as match_total
             FROM {QUOTE}{SCHEMA_NAME}{QUOTE}.{QUOTE}{TABLE_NAME}{QUOTE}
             WHERE {SUBSET_CONDITION}
             GROUP BY {GROUPBY_NAMES}
             {HAVING_CONDITION}
                    UNION ALL
                      SELECT {MATCH_GROUPBY_NAMES}, NULL as total, {MATCH_COLUMN_NAMES} as match_total
             FROM {QUOTE}{MATCH_SCHEMA_NAME}{QUOTE}.{QUOTE}{MATCH_TABLE_NAME}{QUOTE}
             WHERE {MATCH_SUBSET_CONDITION}
             GROUP BY {MATCH_GROUPBY_NAMES}
             {MATCH_HAVING_CONDITION} ) a
               GROUP BY {GROUPBY_NAMES} ) s
               WHERE total <> match_total
                   OR (total IS NOT NULL AND match_total IS NULL)
                   OR (total IS NULL AND match_total IS NOT NULL);
  - id: '2006'
    test_type: Aggregate_Balance
    sql_flavor: redshift
    template: |-
      SELECT '{TEST_TYPE}'   as test_type,
             '{TEST_DEFINITION_ID}' as test_definition_id,
             '{TEST_SUITE_ID}' as test_suite_id,
             '{TEST_RUN_ID}' as test_run_id,
             '{RUN_DATE}'    as test_time,
             '{SCHEMA_NAME}' as schema_name,
             '{TABLE_NAME}'  as table_name,
             '{COLUMN_NAME_NO_QUOTES}' as column_names,
             '{SKIP_ERRORS}' as threshold_value,
             {SKIP_ERRORS} as skip_errors,
             '{INPUT_PARAMETERS}' as input_parameters,
             NULL as result_signal,
             CASE WHEN COUNT (*) > {SKIP_ERRORS} THEN 0 ELSE 1 END as result_code,
             CASE
              WHEN COUNT(*) > 0 THEN
                     CONCAT(
                            CONCAT( CAST(COUNT(*) AS {VARCHAR_TYPE}), ' error(s) identified, ' ),
                            CONCAT(
                                   CASE
                                     WHEN COUNT(*) > {SKIP_ERRORS} THEN 'exceeding limit of '
                                                                              ELSE 'within limit of '
                                   END,
                                   '{SKIP_ERRORS}.'
                                   )
                            )
              ELSE 'No errors found.'
             END AS result_message,
             COUNT(*) as result_measure
      FROM ( SELECT {GROUPBY_NAMES}, SUM(TOTAL) as total, SUM(MATCH_TOTAL) as MATCH_TOTAL
               FROM
                    ( SELECT {GROUPBY_NAMES}, {COLUMN_NAME_NO_QUOTES} as total, NULL as match_total
             FROM {QUOTE}{SCHEMA_NAME}{QUOTE}.{QUOTE}{TABLE_NAME}{QUOTE}
             WHERE {SUBSET_CONDITION}
             GROUP BY {GROUPBY_NAMES}
             {HAVING_CONDITION}
                    UNION ALL
                      SELECT {MATCH_GROUPBY_NAMES}, NULL as total, {MATCH_COLUMN_NAMES} as match_total
             FROM {QUOTE}{MATCH_SCHEMA_NAME}{QUOTE}.{QUOTE}{MATCH_TABLE_NAME}{QUOTE}
             WHERE {MATCH_SUBSET_CONDITION}
             GROUP BY {MATCH_GROUPBY_NAMES}
             {MATCH_HAVING_CONDITION} ) a
               GROUP BY {GROUPBY_NAMES} ) s
               WHERE total <> match_total
                   OR (total IS NOT NULL AND match_total IS NULL)
                   OR (total IS NULL AND match_total IS NOT NULL);
  - id: '2506'
    test_type: Aggregate_Balance
    sql_flavor: redshift_spectrum
    template: |-
      SELECT '{TEST_TYPE}'   as test_type,
             '{TEST_DEFINITION_ID}' as test_definition_id,
             '{TEST_SUITE_ID}' as test_suite_id,
             '{TEST_RUN_ID}' as test_run_id,
             '{RUN_DATE}'    as test_time,
             '{SCHEMA_NAME}' as schema_name,
             '{TABLE_NAME}'  as table_name,
             '{COLUMN_NAME_NO_QUOTES}' as column_names,
             '{SKIP_ERRORS}' as threshold_value,
             {SKIP_ERRORS} as skip_errors,
             '{INPUT_PARAMETERS}' as input_parameters,
             NULL as result_signal,
             CASE WHEN COUNT (*) > {SKIP_ERRORS} THEN 0 ELSE 1 END as result_code,
             CASE
              WHEN COUNT(*) > 0 THEN
                     CONCAT(
                            CONCAT( CAST(COUNT(*) AS {VARCHAR_TYPE}), ' error(s) identified, ' ),
                            CONCAT(
                                   CASE
                                     WHEN COUNT(*) > {SKIP_ERRORS} THEN 'exceeding limit of '
                                                                              ELSE 'within limit of '
                                   END,
                                   '{SKIP_ERRORS}.'
                                   )
                            )
              ELSE 'No errors found.'
             END AS result_message,
             COUNT(*) as result_measure
      FROM ( SELECT {GROUPBY_NAMES}, SUM(TOTAL) as total, SUM(MATCH_TOTAL) as MATCH_TOTAL
               FROM
                    ( SELECT {GROUPBY_NAMES}, {COLUMN_NAME_NO_QUOTES} as total, NULL as match_total
             FROM {QUOTE}{SCHEMA_NAME}{QUOTE}.{QUOTE}{TABLE_NAME}{QUOTE}
             WHERE {SUBSET_CONDITION}
             GROUP BY {GROUPBY_NAMES}
             {HAVING_CONDITION}
                    UNION ALL
                      SELECT {MATCH_GROUPBY_NAMES}, NULL as total, {MATCH_COLUMN_NAMES} as match_total
             FROM {QUOTE}{MATCH_SCHEMA_NAME}{QUOTE}.{QUOTE}{MATCH_TABLE_NAME}{QUOTE}
             WHERE {MATCH_SUBSET_CONDITION}
             GROUP BY {MATCH_GROUPBY_NAMES}
             {MATCH_HAVING_CONDITION} ) a
               GROUP BY {GROUPBY_NAMES} ) s
               WHERE total <> match_total
                   OR (total IS NOT NULL AND match_total IS NULL)
                   OR (total IS NULL AND match_total IS NOT NULL);
  - id: '2106'
    test_type: Aggregate_Balance
    sql_flavor: snowflake
    template: |-
      SELECT '{TEST_TYPE}'   as test_type,
             '{TEST_DEFINITION_ID}' as test_definition_id,
             '{TEST_SUITE_ID}' as test_suite_id,
             '{TEST_RUN_ID}' as test_run_id,
             '{RUN_DATE}'    as test_time,
             '{SCHEMA_NAME}' as schema_name,
             '{TABLE_NAME}'  as table_name,
             '{COLUMN_NAME_NO_QUOTES}' as column_names,
             '{SKIP_ERRORS}' as threshold_value,
             {SKIP_ERRORS} as skip_errors,
             '{INPUT_PARAMETERS}' as input_parameters,
             NULL as result_signal,
             CASE WHEN COUNT (*) > {SKIP_ERRORS} THEN 0 ELSE 1 END as result_code,
             CASE
              WHEN COUNT(*) > 0 THEN
                     CONCAT(
                            CONCAT( CAST(COUNT(*) AS {VARCHAR_TYPE}), ' error(s) identified, ' ),
                            CONCAT(
                                   CASE
                                     WHEN COUNT(*) > {SKIP_ERRORS} THEN 'exceeding limit of '
                                                                              ELSE 'within limit of '
                                   END,
                                   '{SKIP_ERRORS}.'
                                   )
                            )
              ELSE 'No errors found.'
             END AS result_message,
             COUNT(*) as result_measure
      FROM ( SELECT {GROUPBY_NAMES}, SUM(TOTAL) as total, SUM(MATCH_TOTAL) as MATCH_TOTAL
               FROM
                    ( SELECT {GROUPBY_NAMES}, {COLUMN_NAME_NO_QUOTES} as total, NULL as match_total
             FROM {QUOTE}{SCHEMA_NAME}{QUOTE}.{QUOTE}{TABLE_NAME}{QUOTE}
             WHERE {SUBSET_CONDITION}
             GROUP BY {GROUPBY_NAMES}
             {HAVING_CONDITION}
                    UNION ALL
                      SELECT {MATCH_GROUPBY_NAMES}, NULL as total, {MATCH_COLUMN_NAMES} as match_total
             FROM {QUOTE}{MATCH_SCHEMA_NAME}{QUOTE}.{QUOTE}{MATCH_TABLE_NAME}{QUOTE}
             WHERE {MATCH_SUBSET_CONDITION}
             GROUP BY {MATCH_GROUPBY_NAMES}
             {MATCH_HAVING_CONDITION} ) a
               GROUP BY {GROUPBY_NAMES} ) s
               WHERE total <> match_total
                   OR (total IS NOT NULL AND match_total IS NULL)
                   OR (total IS NULL AND match_total IS NOT NULL);
