test_types:
  id: '1510'
  test_type: Dupe_Rows
  test_name_short: Duplicate Rows
  test_name_long: Rows are not duplicated in table
  test_description: |-
    Tests for the absence of duplicate rows based on unique combination of column values.
  except_message: |-
    Column value combinations are duplicated in the table.
  measure_uom: Duplicate records
  measure_uom_description: null
  selection_criteria: |-
    TEMPLATE
  generation_template: gen_Dupe_Rows.sql
  dq_score_prevalence_formula: |-
    (({RESULT_MEASURE}-{THRESHOLD_VALUE}))::FLOAT/NULLIF({RECORD_CT}::FLOAT, 0)
  dq_score_risk_factor: '1.0'
  column_name_prompt: |-
    null
  column_name_help: |-
    null
  default_parm_columns: groupby_names
  default_parm_values: null
  default_parm_prompts: |-
    Columns to Compare
  default_parm_help: |-
    List of columns in the table that define a duplicate record when the combination of values is repeated on multiple rows
  default_severity: Fail
  run_type: QUERY
  test_scope: table
  dq_dimension: Uniqueness
  health_dimension: Schema Drift
  threshold_description: |-
    Expected count of duplicate value combinations
  result_visualization: line_chart
  result_visualization_params: null
  usage_notes: |-
    This test verifies that combinations of values are not repeated within the table. By default when auto-generated, the test considers all columns to protect against duplication of entire rows. If you know the minimum columns that should constitute a unique record, such as a set of ID's, you should use those to make the test as sensitive as possible. Alternatively, if you know of columns you can always exclude, such as file_date or refresh_snapshot_id, remove them to tighten the test somewhat.
  active: Y
  cat_test_conditions: []
  target_data_lookups:
  - id: '1409'
    test_id: '1510'
    test_type: Dupe_Rows
    sql_flavor: bigquery
    lookup_type: null
    lookup_query: |-
      SELECT {GROUPBY_NAMES}, COUNT(*) AS record_ct
      FROM `{TARGET_SCHEMA}`.`{TABLE_NAME}`
      WHERE {SUBSET_CONDITION}
      GROUP BY {GROUPBY_NAMES}
      HAVING COUNT(*) > 1
      ORDER BY {GROUPBY_NAMES}
      LIMIT {LIMIT};
    error_type: Test Results
  - id: '1257'
    test_id: '1510'
    test_type: Dupe_Rows
    sql_flavor: databricks
    lookup_type: null
    lookup_query: |-
      SELECT {GROUPBY_NAMES}, COUNT(*) as record_ct
                 FROM `{TARGET_SCHEMA}`.`{TABLE_NAME}`
                 WHERE {SUBSET_CONDITION}
               GROUP BY {GROUPBY_NAMES}
               HAVING COUNT(*) > 1
      ORDER BY {GROUPBY_NAMES}
      LIMIT {LIMIT};
    error_type: Test Results
  - id: '1255'
    test_id: '1510'
    test_type: Dupe_Rows
    sql_flavor: mssql
    lookup_type: null
    lookup_query: |-
      SELECT TOP {LIMIT} {GROUPBY_NAMES}, COUNT(*) as record_ct
                 FROM "{TARGET_SCHEMA}"."{TABLE_NAME}"
                 WHERE {SUBSET_CONDITION}
               GROUP BY {GROUPBY_NAMES}
               HAVING COUNT(*) > 1
      ORDER BY {GROUPBY_NAMES}
    error_type: Test Results
  - id: '1256'
    test_id: '1510'
    test_type: Dupe_Rows
    sql_flavor: postgresql
    lookup_type: null
    lookup_query: |-
      SELECT {GROUPBY_NAMES}, COUNT(*) as record_ct
                 FROM "{TARGET_SCHEMA}"."{TABLE_NAME}"
                 WHERE {SUBSET_CONDITION}
               GROUP BY {GROUPBY_NAMES}
               HAVING COUNT(*) > 1
      ORDER BY {GROUPBY_NAMES}
      LIMIT {LIMIT};
    error_type: Test Results
  - id: '1253'
    test_id: '1510'
    test_type: Dupe_Rows
    sql_flavor: redshift
    lookup_type: null
    lookup_query: |-
      SELECT {GROUPBY_NAMES}, COUNT(*) as record_ct
                 FROM "{TARGET_SCHEMA}"."{TABLE_NAME}"
                 WHERE {SUBSET_CONDITION}
               GROUP BY {GROUPBY_NAMES}
               HAVING COUNT(*) > 1
      ORDER BY {GROUPBY_NAMES}
      LIMIT {LIMIT};
    error_type: Test Results
  - id: '1472'
    test_id: '1510'
    test_type: Dupe_Rows
    sql_flavor: redshift_spectrum
    lookup_type: null
    lookup_query: |-
      SELECT {GROUPBY_NAMES}, COUNT(*) as record_ct
                 FROM "{TARGET_SCHEMA}"."{TABLE_NAME}"
                 WHERE {SUBSET_CONDITION}
               GROUP BY {GROUPBY_NAMES}
               HAVING COUNT(*) > 1
      ORDER BY {GROUPBY_NAMES}
      LIMIT {LIMIT};
    error_type: Test Results
  - id: '1254'
    test_id: '1510'
    test_type: Dupe_Rows
    sql_flavor: snowflake
    lookup_type: null
    lookup_query: |-
      SELECT {GROUPBY_NAMES}, COUNT(*) as record_ct
                 FROM "{TARGET_SCHEMA}"."{TABLE_NAME}"
                 WHERE {SUBSET_CONDITION}
               GROUP BY {GROUPBY_NAMES}
               HAVING COUNT(*) > 1
      ORDER BY {GROUPBY_NAMES}
      LIMIT {LIMIT};
    error_type: Test Results
  test_templates:
  - id: '2511'
    test_type: Dupe_Rows
    sql_flavor: bigquery
    template: |-
      SELECT '{TEST_TYPE}'   as test_type,
             '{TEST_DEFINITION_ID}' as test_definition_id,
             '{TEST_SUITE_ID}' as test_suite_id,
             '{TEST_RUN_ID}' as test_run_id,
             '{RUN_DATE}'    as test_time,
             '{SCHEMA_NAME}' as schema_name,
             '{TABLE_NAME}'  as table_name,
             '{COLUMN_NAME_NO_QUOTES}' as column_names,
             '{SKIP_ERRORS}' as threshold_value,
             {SKIP_ERRORS} as skip_errors,
             '{INPUT_PARAMETERS}' as input_parameters,
             NULL as result_signal,
             CASE WHEN COUNT (*) > {SKIP_ERRORS} THEN 0 ELSE 1 END as result_code,
             CASE
              WHEN COUNT(*) > 0 THEN
                     CONCAT(
                            CONCAT( CAST(COUNT(*) AS {VARCHAR_TYPE}), ' duplicate row(s) identified, ' ),
                            CONCAT(
                                   CASE
                                     WHEN COUNT(*) > {SKIP_ERRORS} THEN 'exceeding limit of '
                                                                              ELSE 'within limit of '
                                   END,
                                   '{SKIP_ERRORS}.'
                                   )
                            )
              ELSE 'No errors found.'
             END AS result_message,
             COALESCE(SUM(record_ct), 0) as result_measure
        FROM ( SELECT {GROUPBY_NAMES}, COUNT(*) as record_ct
                 FROM {QUOTE}{SCHEMA_NAME}{QUOTE}.{QUOTE}{TABLE_NAME}{QUOTE}
                 WHERE {SUBSET_CONDITION}
               GROUP BY {GROUPBY_NAMES}
               HAVING COUNT(*) > 1
             ) test;
  - id: '2411'
    test_type: Dupe_Rows
    sql_flavor: databricks
    template: |-
      SELECT '{TEST_TYPE}'   as test_type,
             '{TEST_DEFINITION_ID}' as test_definition_id,
             '{TEST_SUITE_ID}' as test_suite_id,
             '{TEST_RUN_ID}' as test_run_id,
             '{RUN_DATE}'    as test_time,
             '{SCHEMA_NAME}' as schema_name,
             '{TABLE_NAME}'  as table_name,
             '{COLUMN_NAME_NO_QUOTES}' as column_names,
             '{SKIP_ERRORS}' as threshold_value,
             {SKIP_ERRORS} as skip_errors,
             '{INPUT_PARAMETERS}' as input_parameters,
             NULL as result_signal,
             CASE WHEN COUNT (*) > {SKIP_ERRORS} THEN 0 ELSE 1 END as result_code,
             CASE
              WHEN COUNT(*) > 0 THEN
                     CONCAT(
                            CONCAT( CAST(COUNT(*) AS {VARCHAR_TYPE}), ' duplicate row(s) identified, ' ),
                            CONCAT(
                                   CASE
                                     WHEN COUNT(*) > {SKIP_ERRORS} THEN 'exceeding limit of '
                                                                              ELSE 'within limit of '
                                   END,
                                   '{SKIP_ERRORS}.'
                                   )
                            )
              ELSE 'No errors found.'
             END AS result_message,
             COALESCE(SUM(record_ct), 0) as result_measure
        FROM ( SELECT {GROUPBY_NAMES}, COUNT(*) as record_ct
                 FROM {QUOTE}{SCHEMA_NAME}{QUOTE}.{QUOTE}{TABLE_NAME}{QUOTE}
                 WHERE {SUBSET_CONDITION}
               GROUP BY {GROUPBY_NAMES}
               HAVING COUNT(*) > 1
             ) test;
  - id: '2211'
    test_type: Dupe_Rows
    sql_flavor: mssql
    template: |-
      SELECT '{TEST_TYPE}'   as test_type,
             '{TEST_DEFINITION_ID}' as test_definition_id,
             '{TEST_SUITE_ID}' as test_suite_id,
             '{TEST_RUN_ID}' as test_run_id,
             '{RUN_DATE}'    as test_time,
             '{SCHEMA_NAME}' as schema_name,
             '{TABLE_NAME}'  as table_name,
             '{COLUMN_NAME_NO_QUOTES}' as column_names,
             '{SKIP_ERRORS}' as threshold_value,
             {SKIP_ERRORS} as skip_errors,
             '{INPUT_PARAMETERS}' as input_parameters,
             NULL as result_signal,
             CASE WHEN COUNT (*) > {SKIP_ERRORS} THEN 0 ELSE 1 END as result_code,
             CASE
              WHEN COUNT(*) > 0 THEN
                     CONCAT(
                            CONCAT( CAST(COUNT(*) AS {VARCHAR_TYPE}), ' duplicate row(s) identified, ' ),
                            CONCAT(
                                   CASE
                                     WHEN COUNT(*) > {SKIP_ERRORS} THEN 'exceeding limit of '
                                                                              ELSE 'within limit of '
                                   END,
                                   '{SKIP_ERRORS}.'
                                   )
                            )
              ELSE 'No errors found.'
             END AS result_message,
             COALESCE(SUM(record_ct), 0) as result_measure
        FROM ( SELECT {GROUPBY_NAMES}, COUNT(*) as record_ct
                 FROM {QUOTE}{SCHEMA_NAME}{QUOTE}.{QUOTE}{TABLE_NAME}{QUOTE}
                 WHERE {SUBSET_CONDITION}
               GROUP BY {GROUPBY_NAMES}
               HAVING COUNT(*) > 1
             ) test;
  - id: '2311'
    test_type: Dupe_Rows
    sql_flavor: postgresql
    template: |-
      SELECT '{TEST_TYPE}'   as test_type,
             '{TEST_DEFINITION_ID}' as test_definition_id,
             '{TEST_SUITE_ID}' as test_suite_id,
             '{TEST_RUN_ID}' as test_run_id,
             '{RUN_DATE}'    as test_time,
             '{SCHEMA_NAME}' as schema_name,
             '{TABLE_NAME}'  as table_name,
             '{COLUMN_NAME_NO_QUOTES}' as column_names,
             '{SKIP_ERRORS}' as threshold_value,
             {SKIP_ERRORS} as skip_errors,
             '{INPUT_PARAMETERS}' as input_parameters,
             NULL as result_signal,
             CASE WHEN COUNT (*) > {SKIP_ERRORS} THEN 0 ELSE 1 END as result_code,
             CASE
              WHEN COUNT(*) > 0 THEN
                     CONCAT(
                            CONCAT( CAST(COUNT(*) AS {VARCHAR_TYPE}), ' duplicate row(s) identified, ' ),
                            CONCAT(
                                   CASE
                                     WHEN COUNT(*) > {SKIP_ERRORS} THEN 'exceeding limit of '
                                                                              ELSE 'within limit of '
                                   END,
                                   '{SKIP_ERRORS}.'
                                   )
                            )
              ELSE 'No errors found.'
             END AS result_message,
             COALESCE(SUM(record_ct), 0) as result_measure
        FROM ( SELECT {GROUPBY_NAMES}, COUNT(*) as record_ct
                 FROM {QUOTE}{SCHEMA_NAME}{QUOTE}.{QUOTE}{TABLE_NAME}{QUOTE}
                 WHERE {SUBSET_CONDITION}
               GROUP BY {GROUPBY_NAMES}
               HAVING COUNT(*) > 1
             ) test;
  - id: '2011'
    test_type: Dupe_Rows
    sql_flavor: redshift
    template: |-
      SELECT '{TEST_TYPE}'   as test_type,
             '{TEST_DEFINITION_ID}' as test_definition_id,
             '{TEST_SUITE_ID}' as test_suite_id,
             '{TEST_RUN_ID}' as test_run_id,
             '{RUN_DATE}'    as test_time,
             '{SCHEMA_NAME}' as schema_name,
             '{TABLE_NAME}'  as table_name,
             '{COLUMN_NAME_NO_QUOTES}' as column_names,
             '{SKIP_ERRORS}' as threshold_value,
             {SKIP_ERRORS} as skip_errors,
             '{INPUT_PARAMETERS}' as input_parameters,
             NULL as result_signal,
             CASE WHEN COUNT (*) > {SKIP_ERRORS} THEN 0 ELSE 1 END as result_code,
             CASE
              WHEN COUNT(*) > 0 THEN
                     CONCAT(
                            CONCAT( CAST(COUNT(*) AS {VARCHAR_TYPE}), ' duplicate row(s) identified, ' ),
                            CONCAT(
                                   CASE
                                     WHEN COUNT(*) > {SKIP_ERRORS} THEN 'exceeding limit of '
                                                                              ELSE 'within limit of '
                                   END,
                                   '{SKIP_ERRORS}.'
                                   )
                            )
              ELSE 'No errors found.'
             END AS result_message,
             COALESCE(SUM(record_ct), 0) as result_measure
        FROM ( SELECT {GROUPBY_NAMES}, COUNT(*) as record_ct
                 FROM {QUOTE}{SCHEMA_NAME}{QUOTE}.{QUOTE}{TABLE_NAME}{QUOTE}
                 WHERE {SUBSET_CONDITION}
               GROUP BY {GROUPBY_NAMES}
               HAVING COUNT(*) > 1
             ) test;
  - id: '2511'
    test_type: Dupe_Rows
    sql_flavor: redshift_spectrum
    template: |-
      SELECT '{TEST_TYPE}'   as test_type,
             '{TEST_DEFINITION_ID}' as test_definition_id,
             '{TEST_SUITE_ID}' as test_suite_id,
             '{TEST_RUN_ID}' as test_run_id,
             '{RUN_DATE}'    as test_time,
             '{SCHEMA_NAME}' as schema_name,
             '{TABLE_NAME}'  as table_name,
             '{COLUMN_NAME_NO_QUOTES}' as column_names,
             '{SKIP_ERRORS}' as threshold_value,
             {SKIP_ERRORS} as skip_errors,
             '{INPUT_PARAMETERS}' as input_parameters,
             NULL as result_signal,
             CASE WHEN COUNT (*) > {SKIP_ERRORS} THEN 0 ELSE 1 END as result_code,
             CASE
              WHEN COUNT(*) > 0 THEN
                     CONCAT(
                            CONCAT( CAST(COUNT(*) AS {VARCHAR_TYPE}), ' duplicate row(s) identified, ' ),
                            CONCAT(
                                   CASE
                                     WHEN COUNT(*) > {SKIP_ERRORS} THEN 'exceeding limit of '
                                                                              ELSE 'within limit of '
                                   END,
                                   '{SKIP_ERRORS}.'
                                   )
                            )
              ELSE 'No errors found.'
             END AS result_message,
             COALESCE(SUM(record_ct), 0) as result_measure
        FROM ( SELECT {GROUPBY_NAMES}, COUNT(*) as record_ct
                 FROM {QUOTE}{SCHEMA_NAME}{QUOTE}.{QUOTE}{TABLE_NAME}{QUOTE}
                 WHERE {SUBSET_CONDITION}
               GROUP BY {GROUPBY_NAMES}
               HAVING COUNT(*) > 1
             ) test;
  - id: '2111'
    test_type: Dupe_Rows
    sql_flavor: snowflake
    template: |-
      SELECT '{TEST_TYPE}'   as test_type,
             '{TEST_DEFINITION_ID}' as test_definition_id,
             '{TEST_SUITE_ID}' as test_suite_id,
             '{TEST_RUN_ID}' as test_run_id,
             '{RUN_DATE}'    as test_time,
             '{SCHEMA_NAME}' as schema_name,
             '{TABLE_NAME}'  as table_name,
             '{COLUMN_NAME_NO_QUOTES}' as column_names,
             '{SKIP_ERRORS}' as threshold_value,
             {SKIP_ERRORS} as skip_errors,
             '{INPUT_PARAMETERS}' as input_parameters,
             NULL as result_signal,
             CASE WHEN COUNT (*) > {SKIP_ERRORS} THEN 0 ELSE 1 END as result_code,
             CASE
              WHEN COUNT(*) > 0 THEN
                     CONCAT(
                            CONCAT( CAST(COUNT(*) AS {VARCHAR_TYPE}), ' duplicate row(s) identified, ' ),
                            CONCAT(
                                   CASE
                                     WHEN COUNT(*) > {SKIP_ERRORS} THEN 'exceeding limit of '
                                                                              ELSE 'within limit of '
                                   END,
                                   '{SKIP_ERRORS}.'
                                   )
                            )
              ELSE 'No errors found.'
             END AS result_message,
             COALESCE(SUM(record_ct), 0) as result_measure
        FROM ( SELECT {GROUPBY_NAMES}, COUNT(*) as record_ct
                 FROM {QUOTE}{SCHEMA_NAME}{QUOTE}.{QUOTE}{TABLE_NAME}{QUOTE}
                 WHERE {SUBSET_CONDITION}
               GROUP BY {GROUPBY_NAMES}
               HAVING COUNT(*) > 1
             ) test;
